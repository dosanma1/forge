// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/dosanma1/forge/go/kit/monitoring/tracer (interfaces: Tracer)

// Package tracertest is a generated GoMock package.
package tracertest

import (
	context "context"
	reflect "reflect"

	tracer "github.com/dosanma1/forge/go/kit/monitoring/tracer"
	gomock "github.com/golang/mock/gomock"
)

// MockTracer is a mock of Tracer interface.
type MockTracer struct {
	ctrl     *gomock.Controller
	recorder *MockTracerMockRecorder
}

// MockTracerMockRecorder is the mock recorder for MockTracer.
type MockTracerMockRecorder struct {
	mock *MockTracer
}

// NewMockTracer creates a new mock instance.
func NewMockTracer(ctrl *gomock.Controller) *MockTracer {
	mock := &MockTracer{ctrl: ctrl}
	mock.recorder = &MockTracerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTracer) EXPECT() *MockTracerMockRecorder {
	return m.recorder
}

// End mocks base method.
func (m *MockTracer) End(arg0 tracer.Span) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "End", arg0)
}

// End indicates an expected call of End.
func (mr *MockTracerMockRecorder) End(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "End", reflect.TypeOf((*MockTracer)(nil).End), arg0)
}

// InjectParent mocks base method.
func (m *MockTracer) InjectParent(arg0 context.Context, arg1, arg2 string) context.Context {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InjectParent", arg0, arg1, arg2)
	ret0, _ := ret[0].(context.Context)
	return ret0
}

// InjectParent indicates an expected call of InjectParent.
func (mr *MockTracerMockRecorder) InjectParent(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InjectParent", reflect.TypeOf((*MockTracer)(nil).InjectParent), arg0, arg1, arg2)
}

// Propagator mocks base method.
func (m *MockTracer) Propagator() tracer.Propagator {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Propagator")
	ret0, _ := ret[0].(tracer.Propagator)
	return ret0
}

// Propagator indicates an expected call of Propagator.
func (mr *MockTracerMockRecorder) Propagator() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Propagator", reflect.TypeOf((*MockTracer)(nil).Propagator))
}

// SpanFromContext mocks base method.
func (m *MockTracer) SpanFromContext(arg0 context.Context) tracer.Span {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SpanFromContext", arg0)
	ret0, _ := ret[0].(tracer.Span)
	return ret0
}

// SpanFromContext indicates an expected call of SpanFromContext.
func (mr *MockTracerMockRecorder) SpanFromContext(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SpanFromContext", reflect.TypeOf((*MockTracer)(nil).SpanFromContext), arg0)
}

// Start mocks base method.
func (m *MockTracer) Start(arg0 context.Context, arg1 ...tracer.SpanOption) (context.Context, tracer.Span) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Start", varargs...)
	ret0, _ := ret[0].(context.Context)
	ret1, _ := ret[1].(tracer.Span)
	return ret0, ret1
}

// Start indicates an expected call of Start.
func (mr *MockTracerMockRecorder) Start(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockTracer)(nil).Start), varargs...)
}
