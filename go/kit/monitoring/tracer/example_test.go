package tracer_test

import (
	"bytes"
	"context"
	"fmt"
	"net/http"

	"github.com/dosanma1/forge/go/kit/monitoring/tracer"
	"github.com/dosanma1/forge/go/kit/monitoring/tracer/carrier"
	"github.com/dosanma1/forge/go/kit/monitoring/tracer/otel"
)

func ExampleTracer_Start() {
	trace, _ := otel.New("example-service")

	// This would usually be the context of a request instead of context.Background()
	ctx := context.Background()

	// Creates a new span
	_, span := trace.Start(ctx)

	// The most common way to properly close the span is to immediately defer a call to End()
	defer span.End()

	// Alternatively, you can also close the span calling to the End() convenience method in tracer.Tracer
	// defer trace.End(span)
}

func ExampleTracer_Start_obtain_span() {
	trace, _ := otel.New("example-service")

	// This would usually be the context of a request instead of context.Background()
	ctx := context.Background()

	// Creates a new span
	newCtx, _ := trace.Start(ctx)

	// The most recent span can also be obtained from the context,
	// so it could be created and close in a layer and modified in another
	span := trace.SpanFromContext(newCtx)

	span.End()
}

func ExampleSpan() {
	trace, _ := otel.New("example-service")

	// This would usually be the context of a request instead of context.Background()
	ctx := context.Background()

	// Creates a new span
	_, span := trace.Start(ctx)
	defer span.End()

	// You should check if a span has a valid TraceID
	if span.HasTraceID() {
		fmt.Println(span.TraceID().String())
	}

	// You should check if a span has a valid SpanID
	if span.HasSpanID() {
		fmt.Println(span.SpanID().String())
	}

	// Optionally, additional attributes can be added to a span in any point of its lifecycle
	span.SetAttributes(tracer.NewKeyValue("example", "example string"))

	// Optionally, a span can be flagged as a success...
	span.SetOkStatus("everything went ok")

	// ...or an error
	span.SetErrorStatus("everything went ok")

	// Additional events may be added at any point of the lifecycle
	span.AddEvents(tracer.NewEvent(tracer.EventName("published to pub-sub")))
}

func ExampleSpan_HasTraceID() {
	trace, _ := otel.New("example-service")

	// This would usually be the context of a request instead of context.Background()
	ctx := context.Background()

	span := trace.SpanFromContext(ctx)

	// trace.SpanFromContext never fails, but it can return a span with invalid TraceID and/or SpanID.
	// So if a span is obtained from context you should check if a span has a valid TraceID
	// before further interacting with it.
	// The same thing can be done with SpanID.
	// This is the same behaviour as otel's tracer.
	if span.HasTraceID() {
		fmt.Println(span.TraceID().String())
	}
}

func ExampleSpan_propagating_client() {
	trace, _ := otel.New("example-service")

	// It may be needed that spans created in different processes (different microservices, usually)
	// be correlated between them.
	// This is achieved by assigning the same TraceID to all the spans created by the same request
	// (even across different microservices)
	// The propagator does this for you automagically

	// This would usually be the context of a request instead of context.Background()
	ctx := context.Background()

	// Creates a new span
	_, span := trace.Start(ctx)
	defer span.End()

	client := http.Client{}
	request, _ := http.NewRequest(http.MethodGet, "localhost", bytes.NewBuffer([]byte{}))

	// The propagator is going to encode the span information into the header
	// of the request using the HTTPHeaderTextMap Carrier
	trace.Propagator().Inject(ctx, carrier.NewHTTPHeaderTextMapCarrier(request.Header))

	// The span information travels in the request
	res, err := client.Do(request)
	if err != nil {
		return
	}
	defer res.Body.Close()
}

func ExampleSpan_propagating_server() {
	trace, _ := otel.New("example-service")

	// It may be needed that spans created in different processes (different microservices, usually)
	// be correlated between them.
	// This is achieved by assigning the same TraceID to all the spans created by the same request
	// (even across different microservices)
	// The propagator does this for you automagically

	// In a http handler...
	_ = func(_ http.ResponseWriter, r *http.Request) {
		// Extract fills a given context with a generated version of the span encoded in the Header (if any).
		// This would be typically done in a middleware.
		ctx := trace.Propagator().Extract(r.Context(), carrier.NewHTTPHeaderTextMapCarrier(r.Header))

		// Start creates a new span, correlating the TraceID, if possible.
		// If no valid span is found, Start generates a span with a new, autogenerated TraceID.
		_, span := trace.Start(ctx)
		defer span.End()
	}
}

func ExampleEvent() {
	trace, _ := otel.New("example-service")

	// This would usually be the context of a request instead of context.Background()
	ctx := context.Background()

	// Creates a new span
	_, span := trace.Start(ctx)
	defer span.End()

	// Don't forget to add the event to the span.
	span.AddEvents(tracer.NewEvent(tracer.EventName("text event")))
}
